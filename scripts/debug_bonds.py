import jax
import jax.numpy as jnp
import numpy as np
import biotite.structure.io.pdb as pdb
import biotite.structure as struc
from priox.io.parsing import biotite as parsing_biotite
import openmm.app as app
import openmm
import sys

def debug_bonds():
    pdb_path = "data/pdb/1UAO.pdb"
    
    # 1. Load Biotite (JAX MD)
    print("Loading Biotite Structure...")
    pdb_file = pdb.PDBFile.read(pdb_path)
    structure = pdb.get_structure(pdb_file, model=1)
    # Filter solvent/hetero if needed (jax_md_bridge usually does this)
    structure = structure[structure.hetero == False]
    
    # Biotite bonds
    if structure.bonds is None:
        print("Biotite bonds are None! Inferring...")
        # usually jax_md_bridge calls parsing_biotite.load_structure which might infer bonds?
        # Let's check how jax_md_bridge does it.
        # It uses parsing_biotite.from_pdb_file? No.
        # It uses parsing_biotite.parse_pdb(pdb_path).
        pass
        
    # Let's use the exact same loading as jax_md_bridge
    # But we need to see the internal structure object.
    # parsing_biotite.parse_pdb returns (atoms, bonds, residues, etc.)
    # Let's use that.
    
    # 2. Load OpenMM
    print("Loading OpenMM Structure...")
    omm_pdb = app.PDBFile(pdb_path)
    topology = omm_pdb.topology
    # OpenMM PDBFile relies on CONECT or standard residues.
    # But verify_end_to_end_physics uses ForceField.createSystem which adds bonds based on templates.
    # So we should use ForceField to define bonds?
    # Yes, standard PDBFile might miss bonds if CONECT is missing.
    # But createSystem ADDS bonds.
    
    # So we need to compare:
    # A) Biotite bonds (used by JAX to generate torsions)
    # B) OpenMM System bonds (generated by ForceField)
    
    # Load ForceField
    ff = app.ForceField('openmmforcefields/openmmforcefields/ffxml/amber/protein.ff19SB.xml')
    omm_system = ff.createSystem(topology)
    
    # Extract OpenMM bonds
    omm_bonds = set()
    for force in omm_system.getForces():
        if isinstance(force, openmm.HarmonicBondForce):
            for i in range(force.getNumBonds()):
                p1, p2, _, _ = force.getBondParameters(i)
                if p1 > p2: p1, p2 = p2, p1
                omm_bonds.add((p1, p2))
    
    print(f"OpenMM Bonds: {len(omm_bonds)}")
    
    # Extract Biotite bonds (from structure used in JAX)
    # We need to replicate jax_md_bridge loading
    # It uses:
    # structure = pdb.get_structure(pdb.PDBFile.read(pdb_path), model=1)
    # structure = structure[structure.hetero == False]
    # bonds = structure.bonds
    # If bonds is None, it might infer?
    
    # Let's check if bonds are present
    if structure.bonds is None:
        print("Biotite structure.bonds is None initially.")
        # Does it infer?
        # Usually one calls struc.connect_via_residue_names(structure) or similar.
        # Let's see what jax_md_bridge does.
    else:
        print(f"Biotite structure.bonds present: {len(structure.bonds)}")
        
    # Convert Biotite bonds to set
    biotite_bonds = set()
    if structure.bonds is not None:
        bond_array = structure.bonds.as_array()
        for i in range(len(bond_array)):
            p1, p2 = bond_array[i, 0], bond_array[i, 1]
            # Map indices? Biotite indices are local to structure.
            # OpenMM indices are global.
            # If structure is filtered (hetero=False), indices might shift?
            # 1UAO has hetero?
            # Let's assume 1-to-1 mapping for now if we filter same way.
            if p1 > p2: p1, p2 = p2, p1
            biotite_bonds.add((p1, p2))
            
    print(f"Biotite Bonds: {len(biotite_bonds)}")
    
    # Compare
    missing_in_biotite = omm_bonds - biotite_bonds
    extra_in_biotite = biotite_bonds - omm_bonds
    
    print(f"Missing in Biotite: {len(missing_in_biotite)}")
    print(f"Extra in Biotite: {len(extra_in_biotite)}")
    
    if len(missing_in_biotite) > 0:
        print("Sample Missing in Biotite:")
        for p1, p2 in list(missing_in_biotite)[:10]:
            print(f"  {p1}-{p2} ({structure[p1].res_name} {structure[p1].atom_name} - {structure[p2].res_name} {structure[p2].atom_name})")
            
    if len(extra_in_biotite) > 0:
        print("Sample Extra in Biotite:")
        for p1, p2 in list(extra_in_biotite)[:10]:
            print(f"  {p1}-{p2} ({structure[p1].res_name} {structure[p1].atom_name} - {structure[p2].res_name} {structure[p2].atom_name})")

if __name__ == "__main__":
    debug_bonds()
